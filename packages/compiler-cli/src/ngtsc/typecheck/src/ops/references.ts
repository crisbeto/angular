/*!
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {
  TmplAstComponent,
  TmplAstDirective,
  TmplAstElement,
  TmplAstHostElement,
  TmplAstLetDeclaration,
  TmplAstReference,
  TmplAstTemplate,
  TmplAstVariable,
} from '@angular/compiler';
import {TcbNode, TcbOp} from './base';
import type {Context} from './context';
import type {Scope} from './scope';
import {TypeCheckableDirectiveMeta} from '../../api';

/** Types that can referenced locally in a template. */
export type LocalSymbol =
  | TmplAstElement
  | TmplAstTemplate
  | TmplAstVariable
  | TmplAstLetDeclaration
  | TmplAstReference
  | TmplAstHostElement
  | TmplAstComponent
  | TmplAstDirective;

/**
 * A `TcbOp` which creates a variable for a local ref in a template.
 * The initializer for the variable is the variable expression for the directive, template, or
 * element the ref refers to. When the reference is used in the template, those TCB statements will
 * access this variable as well. For example:
 * ```ts
 * var _t1 = document.createElement('div');
 * var _t2 = _t1;
 * _t2.value
 * ```
 * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol
 * for a reference. In most cases, this isn't essential; that is, the information for the symbol
 * could be gathered without this operation using the `BoundTarget`. However, for the case of
 * ng-template references, we will need this reference variable to not only provide a location in
 * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than
 * `TemplateRef<any>` (this work is still TODO).
 *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 * type.
 */
export class TcbReferenceOp extends TcbOp {
  constructor(
    private readonly tcb: Context,
    private readonly scope: Scope,
    private readonly node: TmplAstReference,
    private readonly host: TmplAstElement | TmplAstTemplate | TmplAstComponent | TmplAstDirective,
    private readonly target: TypeCheckableDirectiveMeta | TmplAstTemplate | TmplAstElement,
  ) {
    super();
  }

  // The statement generated by this operation is only used to for the Type Checker
  // so it can map a reference variable in the template directly to a node in the TCB.
  override readonly optional = true;

  override execute(): TcbNode {
    const id = new TcbNode(this.tcb.allocateId());
    let initializer: TcbNode =
      this.target instanceof TmplAstTemplate || this.target instanceof TmplAstElement
        ? this.scope.resolve(this.target)
        : this.scope.resolve(this.host, this.target);

    // The reference is either to an element, an <ng-template> node, or to a directive on an
    // element or template.
    if (
      (this.target instanceof TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||
      !this.tcb.env.config.checkTypeOfNonDomReferences
    ) {
      // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.
      // References to `TemplateRef`s and directives are pinned to 'any' when
      // `checkTypeOfNonDomReferences` is `false`.
      initializer = new TcbNode(`${initializer.print()} as any`);
    } else if (this.target instanceof TmplAstTemplate) {
      // Direct references to an <ng-template> node simply require a value of type
      // `TemplateRef<any>`. To get this, an expression of the form
      // `(_t1 as any as TemplateRef<any>)` is constructed.
      const templateRef = this.tcb.env.tcbReferenceExternalSymbol('@angular/core', 'TemplateRef');
      initializer = new TcbNode(`(${initializer.print()} as any as ${templateRef.print()}<any>)`);
    }
    initializer.addParseSpanInfo(this.node.sourceSpan);
    id.addParseSpanInfo(this.node.keySpan);

    this.scope.addStatement(new TcbNode(`var ${id.print()} = ${initializer.print()}`));
    return id;
  }
}

/**
 * A `TcbOp` which is used when the target of a reference is missing. This operation generates a
 * variable of type any for usages of the invalid reference to resolve to. The invalid reference
 * itself is recorded out-of-band.
 */
export class TcbInvalidReferenceOp extends TcbOp {
  constructor(
    private readonly tcb: Context,
    private readonly scope: Scope,
  ) {
    super();
  }

  // The declaration of a missing reference is only needed when the reference is resolved.
  override readonly optional = true;

  override execute(): TcbNode {
    const id = new TcbNode(this.tcb.allocateId());
    this.scope.addStatement(new TcbNode(`var ${id.print()} = any`));
    return id;
  }
}
