/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {
  ArrowFunction,
  AST,
  AstVisitor,
  ASTWithSource,
  Binary,
  BindingPipe,
  Call,
  Chain,
  Conditional,
  EmptyExpr,
  ImplicitReceiver,
  Interpolation,
  KeyedRead,
  LiteralArray,
  LiteralMap,
  LiteralPrimitive,
  NonNullAssert,
  ParenthesizedExpression,
  PrefixNot,
  PropertyRead,
  RegularExpressionLiteral,
  SafeCall,
  SafeKeyedRead,
  SafePropertyRead,
  SpreadElement,
  TaggedTemplateLiteral,
  TemplateLiteral,
  TemplateLiteralElement,
  ThisReceiver,
  TypeofExpression,
  Unary,
  VoidExpression,
} from '@angular/compiler';
import {TcbNode} from './ops/base';
import {TypeCheckingConfig} from '../api';

/**
 * Convert an `AST` to a `TcbNode` directly, without going through an intermediate `Expression`
 * AST.
 */
export function astToTcbNode(
  ast: AST,
  maybeResolve: (ast: AST) => TcbNode | null,
  config: TypeCheckingConfig,
): TcbNode {
  const translator = new TcbNodeTranslator(maybeResolve, config);
  return translator.translate(ast);
}

class TcbNodeTranslator implements AstVisitor {
  constructor(
    private maybeResolve: (ast: AST) => TcbNode | null,
    private config: TypeCheckingConfig,
  ) {}

  translate(ast: AST): TcbNode {
    if (ast instanceof ASTWithSource) {
      ast = ast.ast;
    }

    // First attempt to let any custom resolution logic provide a translation for the given node.
    const resolved = this.maybeResolve(ast);
    if (resolved !== null) {
      return resolved;
    }

    return ast.visit(this);
  }

  visitUnary(ast: Unary): TcbNode {
    const expr = this.translate(ast.expr);
    const node = new TcbNode(`${ast.operator}${expr.print()}`);
    return node.wrapForDiagnostics().addParseSpanInfo(ast.sourceSpan);
  }

  visitBinary(ast: Binary): TcbNode {
    const lhs = this.translate(ast.left);
    const rhs = this.translate(ast.right);
    lhs.wrapForDiagnostics();
    rhs.wrapForDiagnostics();
    const node = new TcbNode(`${lhs.print()} ${ast.operation} ${rhs.print()}`);
    node.addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitChain(ast: Chain): TcbNode {
    const elements = ast.expressions.map((expr) => this.translate(expr).print());
    const node = new TcbNode(elements.join(', '));
    node.wrapForDiagnostics();
    node.addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitConditional(ast: Conditional): TcbNode {
    const condExpr = this.translate(ast.condition);
    const trueExpr = this.translate(ast.trueExp);
    // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the
    // whole conditional.
    // In the following example, the last source span comment (5,6) could be seen as the
    // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that
    // is immediately before it:
    // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`
    // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`
    const falseExpr = this.translate(ast.falseExp).wrapForTypeChecker();
    const node = new TcbNode(
      `(${condExpr.print()} ? ${trueExpr.print()} : ${falseExpr.print()})`,
    ).addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitImplicitReceiver(ast: ImplicitReceiver): never {
    throw new Error('Method not implemented.');
  }

  visitThisReceiver(ast: ThisReceiver): never {
    throw new Error('Method not implemented.');
  }

  visitRegularExpressionLiteral(ast: RegularExpressionLiteral, context: any): TcbNode {
    const node = new TcbNode(`/${ast.body}/${ast.flags ?? ''}`);
    node.wrapForTypeChecker();
    return node;
  }

  visitInterpolation(ast: Interpolation): TcbNode {
    // Build up a chain of binary + operations to simulate the string concatenation of the
    // interpolation's expressions. The chain is started using an actual string literal to ensure
    // the type is inferred as 'string'.
    const exprs = ast.expressions.map((e) => {
      const node = this.translate(e);
      node.wrapForTypeChecker();
      return node.print();
    });
    return new TcbNode(`"" + ${exprs.join(' + ')}`);
  }

  visitKeyedRead(ast: KeyedRead): TcbNode {
    const receiver = this.translate(ast.receiver).wrapForDiagnostics();
    const key = this.translate(ast.key);
    return new TcbNode(`${receiver.print()}[${key.print()}]`).addParseSpanInfo(ast.sourceSpan);
  }

  visitLiteralArray(ast: LiteralArray): TcbNode {
    const elements = ast.expressions.map((expr) => this.translate(expr));
    let content = `[${elements.map((el) => el.print()).join(', ')}]`;

    // If strictLiteralTypes is disabled, array literals are cast to `any`.
    if (!this.config.strictLiteralTypes) {
      content += ' as any';
    }

    return new TcbNode(content).addParseSpanInfo(ast.sourceSpan);
  }

  visitLiteralMap(ast: LiteralMap): TcbNode {
    const properties = ast.keys.map((key, idx) => {
      const value = this.translate(ast.values[idx]);

      if (key.kind === 'property') {
        const keyNode = new TcbNode(`"${key.key}"`).addParseSpanInfo(key.sourceSpan);
        return `${keyNode.print()}: ${value.print()}`;
      } else {
        return `...${value.print()}`;
      }
    });

    // If strictLiteralTypes is disabled, object literals are cast to `any`.
    return new TcbNode(
      `{ ${properties.join(', ')} }${this.config.strictLiteralTypes ? '' : ' as any'}`,
    ).addParseSpanInfo(ast.sourceSpan);
  }

  visitLiteralPrimitive(ast: LiteralPrimitive): TcbNode {
    let node: TcbNode;
    if (ast.value === undefined) {
      node = new TcbNode('undefined');
    } else if (ast.value === null) {
      node = new TcbNode('null');
    } else if (typeof ast.value === 'string') {
      node = new TcbNode(JSON.stringify(ast.value));
    } else if (typeof ast.value === 'number') {
      if (Number.isNaN(ast.value)) {
        node = new TcbNode('NaN');
      } else if (!Number.isFinite(ast.value)) {
        node = new TcbNode(ast.value > 0 ? 'Infinity' : '-Infinity');
      } else {
        node = new TcbNode(ast.value.toString());
      }
    } else if (typeof ast.value === 'boolean') {
      node = new TcbNode(ast.value + '');
    } else {
      throw Error(`Unsupported AST value of type ${typeof ast.value}`);
    }
    node.addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitNonNullAssert(ast: NonNullAssert): TcbNode {
    const expr = this.translate(ast.expression).wrapForDiagnostics();
    return new TcbNode(`${expr.print()}!`).addParseSpanInfo(ast.sourceSpan);
  }

  visitPipe(ast: BindingPipe): never {
    throw new Error('Method not implemented.');
  }

  visitPrefixNot(ast: PrefixNot): TcbNode {
    const expression = this.translate(ast.expression).wrapForDiagnostics();
    return new TcbNode(`!${expression.print()}`).addParseSpanInfo(ast.sourceSpan);
  }

  visitTypeofExpression(ast: TypeofExpression): TcbNode {
    const expression = this.translate(ast.expression).wrapForDiagnostics();
    return new TcbNode(`typeof ${expression.print()}`).addParseSpanInfo(ast.sourceSpan);
  }

  visitVoidExpression(ast: VoidExpression): TcbNode {
    const expression = this.translate(ast.expression).wrapForDiagnostics();
    return new TcbNode(`void ${expression.print()}`).addParseSpanInfo(ast.sourceSpan);
  }

  visitPropertyRead(ast: PropertyRead): TcbNode {
    // This is a normal property read - convert the receiver to an expression and emit the correct
    // TypeScript expression to read the property.
    const receiver = this.translate(ast.receiver).wrapForDiagnostics();
    return new TcbNode(`${receiver.print()}.${ast.name}`)
      .addParseSpanInfo(ast.nameSpan)
      .wrapForDiagnostics()
      .addParseSpanInfo(ast.sourceSpan);
  }

  visitSafePropertyRead(ast: SafePropertyRead): TcbNode {
    let node: TcbNode;
    const receiver = this.translate(ast.receiver).wrapForDiagnostics();
    const name = new TcbNode(ast.name).addParseSpanInfo(ast.nameSpan);

    // The form of safe property reads depends on whether strictness is in use.
    if (this.config.strictSafeNavigationTypes) {
      // Basically, the return here is either the type of the complete expression with a null-safe
      // property read, or `undefined`. So a ternary is used to create an "or" type:
      // "a?.b" becomes (0 as any ? a!.b : undefined)
      // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.
      node = new TcbNode(`(0 as any ? ${receiver.print()}!.${name.print()} : undefined)`);
    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
      // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe
      // navigation operation. With this bug, the type of the left-hand side is regarded as any.
      // Therefore, the left-hand side only needs repeating in the output (to validate it), and then
      // 'any' is used for the rest of the expression. This is done using a comma operator:
      // "a?.b" becomes (a as any).b, which will of course have type 'any'.
      node = new TcbNode(`(${receiver.print()} as any).${name.print()}`);
    } else {
      // The View Engine bug isn't active, so check the entire type of the expression, but the final
      // result is still inferred as `any`.
      // "a?.b" becomes (a!.b as any)
      node = new TcbNode(`(${receiver.print()}!.${name.print()} as any)`);
    }
    return node.addParseSpanInfo(ast.sourceSpan);
  }

  visitSafeKeyedRead(ast: SafeKeyedRead): TcbNode {
    const receiver = this.translate(ast.receiver).wrapForDiagnostics();
    const key = this.translate(ast.key);
    let node: TcbNode;

    // The form of safe property reads depends on whether strictness is in use.
    if (this.config.strictSafeNavigationTypes) {
      // "a?.[...]" becomes (0 as any ? a![...] : undefined)
      const elementAccess = new TcbNode(`${receiver.print()}![${key.print()}]`).addParseSpanInfo(
        ast.sourceSpan,
      );
      node = new TcbNode(`(0 as any ? ${elementAccess.print()} : undefined)`);
    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
      // "a?.[...]" becomes (a as any)[...]
      node = new TcbNode(`(${receiver.print()} as any)[${key.print()}]`);
    } else {
      // "a?.[...]" becomes (a!.[...] as any)
      const elementAccess = new TcbNode(`${receiver.print()}![${key.print()}]`).addParseSpanInfo(
        ast.sourceSpan,
      );
      node = new TcbNode(`(${elementAccess.print()} as any)`);
    }
    return node.addParseSpanInfo(ast.sourceSpan);
  }

  visitCall(ast: Call): TcbNode {
    const args = ast.args.map((expr) => this.translate(expr));
    const receiver = ast.receiver;
    let expr: TcbNode;

    // For calls that have a property read as receiver, we have to special-case their emit to avoid
    // inserting superfluous parenthesis as they prevent TypeScript from applying a narrowing effect
    // if the method acts as a type guard.
    if (receiver instanceof PropertyRead) {
      const resolved = this.maybeResolve(receiver);
      if (resolved !== null) {
        expr = resolved;
      } else {
        const propertyReceiver = this.translate(receiver.receiver).wrapForDiagnostics();
        expr = new TcbNode(`${propertyReceiver.print()}.${receiver.name}`).addParseSpanInfo(
          receiver.nameSpan,
        );
      }
    } else {
      expr = this.translate(receiver);
    }

    let node: TcbNode;

    // Safe property/keyed reads will produce a ternary whose value is nullable.
    // We have to generate a similar ternary around the call.
    if (ast.receiver instanceof SafePropertyRead || ast.receiver instanceof SafeKeyedRead) {
      node = this.convertToSafeCall(ast, expr, args);
    } else {
      node = new TcbNode(`${expr.print()}(${args.map((arg) => arg.print()).join(', ')})`);
    }

    return node.addParseSpanInfo(ast.sourceSpan);
  }

  visitSafeCall(ast: SafeCall): TcbNode {
    const args = ast.args.map((expr) => this.translate(expr));
    const expr = this.translate(ast.receiver).wrapForDiagnostics();
    return this.convertToSafeCall(ast, expr, args).addParseSpanInfo(ast.sourceSpan);
  }

  visitTemplateLiteral(ast: TemplateLiteral): TcbNode {
    const length = ast.elements.length;
    const head = ast.elements[0];
    let result: string;

    if (length === 1) {
      result = `\`${head.text}\``;
    } else {
      let parts = [`\`${head.text}`];
      const tailIndex = length - 1;

      for (let i = 1; i < tailIndex; i++) {
        const expr = this.translate(ast.expressions[i - 1]);
        parts.push(`\${${expr.print()}}${ast.elements[i].text}`);
      }
      const resolvedExpression = this.translate(ast.expressions[tailIndex - 1]);
      parts.push(`\${${resolvedExpression.print()}}${ast.elements[tailIndex].text}\``);
      result = parts.join('');
    }
    return new TcbNode(result);
  }

  visitTemplateLiteralElement(ast: TemplateLiteralElement, context: any) {
    throw new Error('Method not implemented');
  }

  visitTaggedTemplateLiteral(ast: TaggedTemplateLiteral): TcbNode {
    const tag = this.translate(ast.tag);
    const template = this.visitTemplateLiteral(ast.template);
    return new TcbNode(`${tag.print()}${template.print()}`);
  }

  visitParenthesizedExpression(ast: ParenthesizedExpression): TcbNode {
    const expr = this.translate(ast.expression);
    return new TcbNode(`(${expr.print()})`);
  }

  visitSpreadElement(ast: SpreadElement) {
    const expression = this.translate(ast.expression);
    expression.wrapForDiagnostics();
    const node = new TcbNode(`...${expression.print()}`);
    node.addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitEmptyExpr(ast: EmptyExpr) {
    const node = new TcbNode('undefined');
    node.addParseSpanInfo(ast.sourceSpan);
    return node;
  }

  visitArrowFunction(ast: ArrowFunction): TcbNode {
    const params = ast.parameters
      .map((param) => new TcbNode(param.name).markIgnoreDiagnostics().print())
      .join(', ');
    const body = astToTcbNode(
      ast.body,
      (innerAst) => {
        if (
          !(innerAst instanceof PropertyRead) ||
          innerAst.receiver instanceof ThisReceiver ||
          !(innerAst.receiver instanceof ImplicitReceiver)
        ) {
          return this.maybeResolve(innerAst);
        }

        const correspondingParam = ast.parameters.find((arg) => arg.name === innerAst.name);

        if (correspondingParam) {
          const node = new TcbNode(innerAst.name);
          node.addParseSpanInfo(innerAst.sourceSpan);
          return node;
        }

        return this.maybeResolve(innerAst);
      },
      this.config,
    );

    return new TcbNode(
      `${ast.parameters.length === 1 ? params : `(${params})`} => ${body.print()}`,
    );
  }

  private convertToSafeCall(ast: Call | SafeCall, exprNode: TcbNode, argNodes: TcbNode[]): TcbNode {
    const expr = exprNode.print();
    const args = argNodes.map((node) => node.print()).join(', ');

    if (this.config.strictSafeNavigationTypes) {
      // (0 as any ? a!.method(...) : undefined)
      return new TcbNode(`(0 as any ? ${expr}!(${args}) : undefined)`);
    }

    if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
      // (a as any).method(...)
      return new TcbNode(`(${expr} as any)(${args})`);
    }

    // (a!.method(...) as any)
    return new TcbNode(`(${expr}!(${args}) as any)`);
  }
}

/**
 * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation
 * operation.
 *
 * In View Engine's template type-checker, certain receivers of safe navigation operations will
 * cause a temporary variable to be allocated as part of the checking expression, to save the value
 * of the receiver and use it more than once in the expression. This temporary variable has type
 * 'any'. In practice, this means certain receivers cause View Engine to not check the full
 * expression, and other receivers will receive more complete checking.
 *
 * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the
 * Ivy checker can emulate this bug when needed.
 */
class VeSafeLhsInferenceBugDetector implements AstVisitor {
  private static SINGLETON = new VeSafeLhsInferenceBugDetector();

  static veWillInferAnyFor(ast: Call | SafeCall | SafePropertyRead | SafeKeyedRead) {
    const visitor = VeSafeLhsInferenceBugDetector.SINGLETON;
    return ast instanceof Call ? ast.visit(visitor) : ast.receiver.visit(visitor);
  }

  visitUnary(ast: Unary): boolean {
    return ast.expr.visit(this);
  }
  visitBinary(ast: Binary): boolean {
    return ast.left.visit(this) || ast.right.visit(this);
  }
  visitChain(): boolean {
    return false;
  }
  visitConditional(ast: Conditional): boolean {
    return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);
  }
  visitCall(): boolean {
    return true;
  }
  visitSafeCall(): boolean {
    return false;
  }
  visitImplicitReceiver(): boolean {
    return false;
  }
  visitThisReceiver(): boolean {
    return false;
  }
  visitInterpolation(ast: Interpolation): boolean {
    return ast.expressions.some((exp) => exp.visit(this));
  }
  visitKeyedRead(): boolean {
    return false;
  }
  visitLiteralArray(): boolean {
    return true;
  }
  visitLiteralMap(): boolean {
    return true;
  }
  visitLiteralPrimitive(): boolean {
    return false;
  }
  visitPipe(): boolean {
    return true;
  }
  visitPrefixNot(ast: PrefixNot): boolean {
    return ast.expression.visit(this);
  }
  visitTypeofExpression(ast: TypeofExpression): boolean {
    return ast.expression.visit(this);
  }
  visitVoidExpression(ast: VoidExpression): boolean {
    return ast.expression.visit(this);
  }
  visitNonNullAssert(ast: NonNullAssert): boolean {
    return ast.expression.visit(this);
  }
  visitPropertyRead(): boolean {
    return false;
  }
  visitSafePropertyRead(): boolean {
    return false;
  }
  visitSafeKeyedRead(): boolean {
    return false;
  }
  visitTemplateLiteral() {
    return false;
  }
  visitTemplateLiteralElement() {
    return false;
  }
  visitTaggedTemplateLiteral() {
    return false;
  }
  visitParenthesizedExpression(ast: ParenthesizedExpression) {
    return ast.expression.visit(this);
  }
  visitRegularExpressionLiteral() {
    return false;
  }
  visitSpreadElement(ast: SpreadElement) {
    return ast.expression.visit(this);
  }
  visitArrowFunction(ast: ArrowFunction, context: any) {
    return false;
  }
}
